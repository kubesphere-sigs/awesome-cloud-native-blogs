---
original: "https://blog.container-solutions.com/wtf-is-webassembly"
author: "Kevin Hoffman"
translator: "alabulei"
original: "https://blog.container-solutions.com/wtf-is-webassembly""
reviewer: ["审阅者 A 的 GitHub 账号","审阅者 B 的 GitHub 账号"]
title: "究竟什么是 WebAssembly"
summary: "WebAssembly解释"
categories: "译文"
tags: ["WebAssembly"]
originalPublishDate: 2021-08-02
publishDate: 2021-11-10
---

当每个人都直接将代码部署到“裸机”时，需求超出了我们现有基础架构的容量，因此基础架构演变为虚拟机。虚拟机的使用让我们可以在一个硬件上运行多台机器，这就催生了数据中心。

因为我们超出了数据中心处理部署无数的虚拟机的容量，我们进入了 docker 镜像的时代，现在我们将 docker 镜像部署在部署在裸机之上的虚拟机之上。

WebAssembly 是部署单元的下一个演变。我们已经从自定义镜像的硬盘驱动器到裸机上的巧妙捆绑，然后是虚拟机，再然后是 docker 镜像，现在我们有了一个更小、更快、更便携、更安全的部署单元——WebAssembly 模块。

我们认为你应该关注 WebAssembly，因为我们认为它完全有可能成为我们所知的计算的未来。

那么究竟什么是 WebAssembly 吗？

## WebAssembly 既不是 Web 也不是 Assembly

如果你在网络上研究过 WebAssembly，那么无疑会遇到这个流行的小谚语。它告诉我们很多关于 WebAssembly 不是什么的信息，但它并没有让我们知道 WebAssembly 是什么。希望这篇文章可以消除一些困惑。

首先从 WebAssembly 是一个基于堆栈的虚拟机的概念开始。每台机器（虚拟或其他）都有一组核心原始指令，可用于告诉它做什么。无论你使用哪种高级编程语言，编译器的最终输出都将是一个包含机器级代码的文件。

WebAssembly 是一个虚拟机。它有自己的一套指令，但负责执行它们的机器是虚拟的——它只是你计算机上的另一个进程。这对 WebAssembly 的重要性产生了深远的影响，而且常常被低估。

WebAssembly 使用的指令集是可移植的。这意味着在 WebAssembly 字节码中表达可以在一台机器上运行但不能在另一台机器上运行的东西是不可能的。像 WebAssembly 这样的基于堆栈的虚拟机速度很快，因为管理堆栈和在这些堆栈上执行操作的代码实际上非常简单并且可以高度优化。 WebAssembly 二进制文件（`.wasm` 文件，在本文中我可能将 WebAssembly 简称为“wasm”）也很小。根据你正在构建的内容，功能齐全的 `wasm` 文件以千字节为单位，而不是兆字节或千兆字节。

## 原始

WebAssembly 是原始的，但方式很好。我一直是功能较少的语言的粉丝：设计者花时间和精力减少语言中不应该存在的语言。使 WebAssembly 如此强大的大部分原因——正如我将在这篇文章中所讨论的——是WebAssembly 不能做到的事情。

开发人员经常注意到（和害怕）有关 wasm 的第一件事是 WebAssembly 中唯一的数据类型是数字。函数只能接受和返回整数或浮点数，其中只允许 32 位和 64 位值。

这意味着诸如字符串、哈希映射、数组、树、元组之类的东西——所有我们每天都认为理所当然的好东西——不是核心 WebAssembly 规范的一部分。相反，在编译期间由更高级别的语言将它们转换为 WebAssembly 字节码。

让我们看看 WebAssembly 的核心实际上是什么样子。假设我们有一部分 .wasm 二进制文件，其中包含以下字节：

```
0x41 0x09 0x41 0xA0 0x6A
```

这不一定是规范准确的（二进制格式有一些非常繁琐的编码要求，在这一点上只会让我们感到困惑），但这作为一个例子就足够了。让我们分解一下：

```
* 0x41 - i32 常数
* 0x09 - 值 9
* 0x41 - i32 常数
* 0xA0 - 值 160
* 0x6A - i32 添加
```

第一条指令是 `i32.const` 指令（请记住，WebAssembly 仅支持 i32、f32、i64 和 f64 数字）。这将一个常数值 9 放在堆栈上。下一条指令将值 160 放在堆栈上。第三条指令是 `i32.add`，它从堆栈中弹出两个值，将它们相加，然后将总和放回堆栈中。因此，当虚拟机处理完这些字节码和参数后，它会将值 169 放在堆栈上。

## 可移植的

我已经提到过，WebAssembly 规范中的任何指令都不是特定于操作系统或 CPU 架构的。这意味着，假设主机运行时（例如 Web 浏览器或自定义嵌入器）符合规范，则可以在任何地方解释相同的 WebAssembly 文件，而不需要在意操作系统或 CPU 架构。

这具有巨大的影响，因为这意味着你用 WebAssembly 字节码表达的任何内容都可以编译一次，部署到多个目标，无需做任何修改。我们大多数人都听说过 Java 字节码的支持者中流行的“一次编写，随处部署”的口号，但 [wasm 不仅仅是另一个 JVM](https://dev.to/oayomide/webassembly-another-jvm-4g79) 或 .NET CLR。一方面，Java 字节码并不是真正可移植的，不同的 JVM 可以以完全不同的方式执行，从而破坏了可移植性。 Microsoft 的 .NET Framework 对可移植性做出了类似的声明，但 JVM 和 .NET CLR 都受到（在我看来）太多指令无法移植的问题，其中许多指令违反了可移植性问题。例如，JVM 和 .NET Framework 都允许访问操作系统，这立即使可移植性（和安全性，我将讨论）成为一个问题。

## 快速

主机运行时的工作很简单——读取操作码、管理堆栈和线性内存，并执行操作码指示的任何任务。正是这种简单性使得 WebAssembly 文件的处理速度如此之快。虽然有可用的即时 (JIT) 编译器可以将 wasm 模块编译为本机代码，但许多运行时（如浏览器）仅依赖于解释，就可以非常快速。

## 流媒体

增强 WebAssembly 性能的另一种方式是 wasm 是可流式传输的。 `.wasm` 文件中的指令集和代码组织的性质使其可以流式传输。

解释器可以在其余部分完成下载之前开始执行 WebAssembly 文件中的第一条指令。虚拟机解释器不需要担心跳转指令指向尚未下载的位置，或者尝试访问尚未发现的资源。允许流式传输的 WebAssembly 文件的组织有一种微妙的美感，所有支持 WebAssembly 的主要浏览器也都支持流式执行。

## 小
Wasm 很小。即使 Rust 生成最大的 WebAssembly 二进制文件，也会比 docker 镜像小几个数量级，甚至也比由 Go 或 Rust 生成的独立的、特定于操作系统和 CPU 的二进制文件小。正如我将在下一篇关于 WebAssembly 的博客文章中讨论的那样，有许多框架和自定义嵌入器利用 WebAssembly 的速度和（缺乏）大小来支持在单个主机内运行的数百或数千个小模块。使用当今可用于“传统”编译目标的语言和框架根本不可能实现这种计算密度。

## 安全
WebAssembly 是安全的。默认情况下它是安全的，这是语言和规范的功劳。首先，WebAssembly 模块是反应式的。除非主机运行时请求它，否则它不能做任何事情。其次，wasm 模块无权访问主机运行时的内存；他们利用自己的私有线性内存空间，最终归结为一个大的长字节向量。

WebAssembly 没有内置指令来访问文件系统、写入 socket、操作主机内存、访问网络服务或以任何方式与操作系统交互。虽然像 WASI 这样的标准允许有限的操作系统访问，但这种访问也使用功能令牌来保护，并且主机运行时仍然可以选择拒绝访问基于 WASI 的函数调用。

Wasm 模块通常是纯计算，没有副作用或由主机运行时严格控制的副作用。浏览器运行时允许的副作用包括通过 shims 访问 JavaScript API，以及操作 DOM 的能力（也通过通常由代码生成工具创建的代理代码）。

## 总结

WebAssembly 才出现几年，无论我们是否意识到这一点，它已经存在于我们的每个浏览器中。 Fastly 和 CloudFlare 等公司正在尝试在边缘运行 WebAssembly，在下一篇文章中，我将讨论不同行业如何在云中使用 WebAssembly。

我们长期以来一直认为是计算的圣杯的特性：小尺寸、便携性、安全性、性能，都是我们通过 WebAssembly 获得的东西。我如果你还没有，请开始了解 WebAssembly，因为它很可能会成为未来软件开发人员所做的一切的事情。

